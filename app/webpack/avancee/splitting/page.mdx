# ‚ö° Splitting et Bundling : Optimisation de la Taille des Fichiers

## üß© Code Splitting avec Webpack
Code splitting est une technique qui permet de diviser votre code en morceaux plus petits. Cela peut am√©liorer les performances de votre application en r√©duisant le temps de chargement et en optimisant l'utilisation de la m√©moire du navigateur.

## üß© Dynamic Import()
La syntaxe `import()` permet d'introduire le code splitting de mani√®re dynamique. Au lieu de charger tous les modules en une seule fois, vous pouvez charger des modules sur demande.

üß™ Par exemple, vous pouvez utiliser `import()` pour charger un module seulement lorsque l'utilisateur clique sur un bouton sp√©cifique.

Supposons que nous ayons deux fichiers JavaScript, `main.js` et `other.js`, et nous voulons charger `other.js` uniquement lorsque n√©cessaire.

Voici comment nous pourrions configurer le code splitting pour ces fichiers dans notre fichier de configuration Webpack (`webpack.config.js`) :

```javascript copy
const path = require('path');

module.exports = {
 entry: './src/main.js',
 output: {
   filename: '[name].bundle.js',
   path: path.resolve(__dirname, 'dist'),
 },
};
```

Et voici comment nous pourrions utiliser `import()` dans `main.js` pour charger `other.js` de mani√®re asynchrone :

```javascript copy
console.log('Hello from main.js!');

button.addEventListener('click', async () => {
 const otherModule = await import('./other.js');
 otherModule.doSomething();
});
```

Dans cet exemple, `other.js` n'est charg√© que lorsque l'utilisateur clique sur le bouton. Jusqu'√† ce moment, `other.js` n'est pas inclus dans le bundle principal de l'application.

## üõ†Ô∏è Configuration de SplitChunksPlugin
Le plugin SplitChunks permet de partager des modules communs entre diff√©rents bundles. Cela peut optimiser la mise en cache et r√©duire le temps de chargement initial.

Supposons que nous ayons une application avec plusieurs bundles, et nous voulons partager certains modules communs entre ces bundles pour optimiser la mise en cache et r√©duire le temps de chargement initial.

Voici comment nous pourrions configurer `SplitChunksPlugin` dans notre fichier de configuration Webpack (`webpack.config.js`) :

```javascript copy
const path = require('path');

module.exports = {
 entry: {
   app: './src/app.js',
   admin: './src/admin.js'
 },
 output: {
   filename: '[name].bundle.js',
   path: path.resolve(__dirname, 'dist'),
 },
 optimization: {
   splitChunks: {
     chunks: 'all',
   },
 },
};
```

Dans cet exemple, nous avons deux points d'entr√©e, `app` et `admin`, qui sont configur√©s pour produire deux bundles distincts. Cependant, si ces deux bundles ont des modules en commun, `SplitChunksPlugin` va automatiquement les s√©parer dans un troisi√®me bundle.

üß™ Par exemple, si `app.js` et `admin.js` importent tous deux le module `lodash`, `SplitChunksPlugin` va cr√©er un troisi√®me bundle qui contient `lodash`, et `lodash` sera supprim√© des bundles `app` et `admin`. De cette fa√ßon, `lodash` ne sera t√©l√©charg√© qu'une seule fois par le navigateur, ce qui peut am√©liorer les performances de l'application.

## üß© Tree Shaking

Tree shaking est une technique d'optimisation qui √©limine le code inutilis√© du bundle final. Cela peut r√©duire consid√©rablement la taille du bundle. Voici un exemple de comment cela pourrait √™tre fait avec Webpack.

Supposons que nous ayons un module `utils.js` qui contient plusieurs fonctions, dont certaines ne sont pas utilis√©es dans notre application.

```javascript copy
// utils.js
export function usedFunction() {
 // ...
}

export function unusedFunction() {
 // ...
}
```

Si nous importons uniquement `usedFunction` dans notre application, Webpack peut utiliser tree shaking pour √©liminer `unusedFunction` du bundle final.

```javascript copy
// app.js
import { usedFunction } from './utils';

usedFunction();
```

Dans ce cas, `unusedFunction` ne sera pas inclus dans le bundle final, car il n'est pas utilis√© dans l'application. Cela peut r√©duire la taille du bundle et am√©liorer les performances de l'application.

## üß© Bundle Analysis
L'analyse de bundle est une technique qui permet de visualiser la taille des bundles g√©n√©r√©s. Cela peut vous aider √† identifier les d√©pendances qui contribuent le plus √† la taille du bundle et √† prendre des mesures d'optimisation.

L'analyse de bundle est une technique qui permet de visualiser la taille des bundles g√©n√©r√©s. Cela peut vous aider √† identifier les d√©pendances qui contribuent le plus √† la taille du bundle et √† prendre des mesures d'optimisation.

üß™ Par exemple, vous pouvez utiliser des outils comme Webpack Bundle Analyzer pour voir combien d'espace chaque d√©pendance occupe dans votre bundle.

Pour utiliser Webpack Bundle Analyzer, vous devez d'abord l'installer via npm :

```bash copy
npm install --save-dev webpack-bundle-analyzer
```

Ensuite, vous pouvez ajouter le plugin √† votre configuration Webpack :

```javascript copy
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
 plugins: [
   new BundleAnalyzerPlugin()
 ]
};
```

Maintenant, lorsque vous ex√©cutez votre script de build Webpack, un serveur local sera d√©marr√© et ouvrira une page dans votre navigateur par d√©faut montrant une visualisation interactive de votre bundle.

## üß© Conclusion
En adoptant ces techniques, vous pourrez r√©duire le temps de chargement de votre application et offrir une meilleure exp√©rience utilisateur. Pr√™t √† explorer le monde du splitting et bundling ?