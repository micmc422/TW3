---
description: "La gestion asynchrone est l'un des concepts les plus puissants de Node.js, rendant possible l'ex√©cution de t√¢ches sans bloquer l'application. Cela permet de r√©aliser plusieurs op√©rations en parall√®le sans interrompre le flux du programme, ce qui est particuli√®rement utile dans les applications √† forte charge, comme les serveurs web."
---
# üü© **Node.js et gestion asynchrone**

La gestion asynchrone est l'un des concepts les plus puissants de Node.js, rendant possible l'ex√©cution de t√¢ches sans bloquer l'application. Cela permet de r√©aliser plusieurs op√©rations en parall√®le sans interrompre le flux du programme, ce qui est particuli√®rement utile dans les applications √† forte charge, comme les serveurs web.

## üîÑ Programmation asynchrone avec des callbacks

Node.js utilise un mod√®le **non-bloquant**, ce qui signifie que lorsqu'une op√©ration est d√©clench√©e, elle ne bloque pas le reste du programme. En d'autres termes, au lieu d'attendre qu'une t√¢che soit termin√©e, Node.js continue d'ex√©cuter le reste du code et g√®re le r√©sultat de l'op√©ration de mani√®re asynchrone.

Les **callbacks** sont une m√©thode classique pour g√©rer cette asynchronicit√©. Un callback est une fonction pass√©e en argument d'une autre fonction et appel√©e une fois que la t√¢che asynchrone est termin√©e.

üß™ Exemple d'utilisation avec le module `fs` pour lire un fichier de mani√®re asynchrone :

```javascript copy
const fs = require('fs');

// Lire un fichier de mani√®re asynchrone avec un callback
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Erreur de lecture du fichier:', err);
    return;
  }
  console.log('Contenu du fichier:', data);
});
```

Dans cet exemple, la fonction `fs.readFile()` d√©clenche la lecture du fichier, et une fois que l'op√©ration est termin√©e, elle ex√©cute la fonction callback. Si une erreur survient (par exemple, si le fichier n'existe pas), elle est g√©r√©e via l'objet `err`.

## üü© ‚è≥ Les Promesses et async/await

Les **Promesses** sont une alternative moderne aux callbacks pour g√©rer l'asynchronie. Elles permettent de rendre le code plus lisible et d'√©viter les fameux "callback hell" (encha√Ænements complexes de callbacks).

Une **Promesse** repr√©sente la valeur d'une op√©ration asynchrone qui sera remplie dans le futur. Elle peut √™tre en trois √©tats : *pending* (en attente), *fulfilled* (r√©ussie), ou *rejected* (√©chou√©e).

üß™ Exemple de Promesse avec la m√©thode `readFile` :

```javascript copy
const fs = require('fs').promises;

fs.readFile('example.txt', 'utf8')
  .then((data) => {
    console.log('Contenu du fichier :', data);
  })
  .catch((err) => {
    console.error('Erreur de lecture du fichier :', err);
  });
```

La syntaxe **`async/await`** simplifie encore plus l'utilisation des Promesses en permettant de traiter le code asynchrone comme s'il √©tait synchrone.

Voici l'exemple pr√©c√©dent r√©√©crit avec `async/await` :

```javascript copy
const fs = require('fs').promises;

async function lireFichier() {
  try {
    const data = await fs.readFile('example.txt', 'utf8');
    console.log('Contenu du fichier :', data);
  } catch (err) {
    console.error('Erreur de lecture du fichier :', err);
  }
}

lireFichier();
```

Avec `async/await`, le code est plus lisible et plus facile √† comprendre. La fonction `lireFichier` est marqu√©e comme `async`, ce qui permet d'utiliser `await` pour attendre que la Promesse soit r√©solue.

## üìù Exercice pratique

1. **R√©√©crire un code bas√© sur des callbacks en utilisant des Promesses :**

Prenez un code existant utilisant des callbacks (comme dans l'exemple `fs.readFile()`) et r√©√©crivez-le en utilisant des Promesses.

2. **Utiliser `async/await` pour simplifier le code :**

Transformez ensuite ce code utilisant des Promesses en une version plus lisible avec `async/await`.