# ğŸš€ **CrÃ©ation dâ€™une Server Action pour gÃ©rer un formulaire dans Next.js 13+**  

Les **Server Actions** permettent dâ€™envoyer directement des donnÃ©es Ã  un serveur **sans API Route**, ce qui simplifie la gestion des formulaires.  

---  

## **1ï¸âƒ£ Objectif : Formulaire de contact avec Server Actions**  

Nous allons crÃ©er un **formulaire de contact** qui envoie les donnÃ©es Ã  une **Server Action** et affiche un message de confirmation.  

âœ… **Ce que nous allons faire** :
- Un **formulaire en React** (`app/contact/page.tsx`).
- Une **Server Action** (`app/actions/contact.ts`).
- Afficher un **message de confirmation aprÃ¨s soumission**.

---

## **2ï¸âƒ£ CrÃ©ation de la Server Action**  

```tsx filename="app/actions/contact.ts" copy
"use server";

export async function sendMessage(formData: FormData) {
  const name = formData.get("name") as string;
  const email = formData.get("email") as string;
  const message = formData.get("message") as string;

  // VÃ©rification des champs
  if (!name || !email || !message) {
    return { error: "Tous les champs sont requis." };
  }

  // Simuler l'envoi Ã  une base de donnÃ©es ou un service (ex: email)
  console.log("Message reÃ§u :", { name, email, message });

  return { success: "Votre message a bien Ã©tÃ© envoyÃ© !" };
}
```

âœ… **Explication** :
- On dÃ©finit la fonction **`sendMessage`** avec **`"use server"`** pour quâ€™elle sâ€™exÃ©cute cÃ´tÃ© serveur.
- On rÃ©cupÃ¨re les donnÃ©es du formulaire via **`formData.get()`**.
- On effectue une validation basique.
- On affiche une rÃ©ponse de succÃ¨s ou dâ€™erreur.

---

## **3ï¸âƒ£ CrÃ©ation du formulaire avec appel Ã  la Server Action**  

```tsx filename="app/contact/page.tsx" copy
"use client";

import { useState } from "react";
import { sendMessage } from "@/app/actions/contact";

export default function ContactPage() {
  const [status, setStatus] = useState<string | null>(null);

  async function handleSubmit(formData: FormData) {
    const result = await sendMessage(formData);
    if (result?.error) {
      setStatus(result.error);
    } else {
      setStatus(result.success);
    }
  }

  return (
    <div className="max-w-md mx-auto p-4 border rounded-lg shadow-lg">
      <h1 className="text-xl font-bold mb-4">Contactez-nous</h1>
      <form action={handleSubmit} className="space-y-3">
        <input
          type="text"
          name="name"
          placeholder="Votre nom"
          className="w-full p-2 border rounded"
          required
        />
        <input
          type="email"
          name="email"
          placeholder="Votre email"
          className="w-full p-2 border rounded"
          required
        />
        <textarea
          name="message"
          placeholder="Votre message"
          className="w-full p-2 border rounded"
          rows={4}
          required
        ></textarea>
        <button type="submit" className="w-full bg-blue-500 text-white py-2 rounded">
          Envoyer
        </button>
      </form>
      {status && <p className="mt-3 text-center">{status}</p>}
    </div>
  );
}
```

âœ… **Explication** :
- Le formulaire est **cÃ´tÃ© client** (`"use client"`).
- La Server Action **`sendMessage`** est appelÃ©e directement **dans `handleSubmit`**.
- On affiche **un message de confirmation** aprÃ¨s lâ€™envoi.

---

## **4ï¸âƒ£ Test et Validation**  

- ğŸ“Œ DÃ©marrer le projet :  
  ```bash
  npm run dev
  ```
- ğŸ“ Aller sur **`http://localhost:3000/contact`**.
- âœ… Remplir le formulaire et envoyer un message.
- ğŸ¯ VÃ©rifier la console serveur pour voir les donnÃ©es envoyÃ©es.

---

## **5ï¸âƒ£ Aller plus loin : Stocker les messages en base de donnÃ©es**  

Si on utilise **Prisma** avec une base de donnÃ©es SQLite ou PostgreSQL :  

```tsx filename="app/actions/contact.ts (avec Prisma)" copy
"use server";

import { db } from "@/lib/db"; // Connexion Ã  la base

export async function sendMessage(formData: FormData) {
  const name = formData.get("name") as string;
  const email = formData.get("email") as string;
  const message = formData.get("message") as string;

  if (!name || !email || !message) {
    return { error: "Tous les champs sont requis." };
  }

  await db.message.create({
    data: { name, email, content: message },
  });

  return { success: "Message enregistrÃ© en base de donnÃ©es !" };
}
```

âœ… **Effet** : Le message est **enregistrÃ© en base de donnÃ©es**.

---

## **6ï¸âƒ£ Comparaison avec une API Route**  

| ğŸ”¹ MÃ©thode | Server Action (`"use server"`) | API Route (`app/api/contact/route.ts`) |
|------------|----------------|----------------|
| ğŸ—ï¸ **ComplexitÃ©** | Plus simple (directement dans le composant) | NÃ©cessite une route sÃ©parÃ©e |
| âš¡ **Performance** | Moins dâ€™allers-retours rÃ©seau | Requiert un `fetch()` |
| ğŸ”’ **SÃ©curitÃ©** | Non exposÃ© cÃ´tÃ© client | Peut Ãªtre accÃ©dÃ© via `fetch()` |
| ğŸ”„ **ExÃ©cution** | Directe via `form action={}` | Via `fetch()` dans un `useEffect` ou `onSubmit` |

---

## **ğŸ¯ Conclusion : Pourquoi utiliser les Server Actions ?**  

ğŸ”¥ **Avantages** :
- **Code plus simple** et lisible.
- **Pas de `fetch()`**, appel direct Ã  la fonction serveur.
- **SÃ©curisÃ©** (aucune API exposÃ©e).
- **Performance optimisÃ©e** (moins de requÃªtes rÃ©seau).