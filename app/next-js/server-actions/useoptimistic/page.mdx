# ğŸš€ **Gestion des mutations avec `useOptimistic` dans Next.js 13+**  

Lâ€™optimistic UI amÃ©liore lâ€™expÃ©rience utilisateur en affichant **immÃ©diatement** une mise Ã  jour de lâ€™interface avant mÃªme la fin du traitement serveur.  
Dans <Term word="Next.js">Next.js</Term> 13+, on utilise **`useOptimistic`** pour gÃ©rer ces mutations cÃ´tÃ© client tout en tirant parti des **Server Actions**.  

---

## **1ï¸âƒ£ Pourquoi utiliser `useOptimistic` ?**  

âœ… **Avantages** :  
- Affichage **instantanÃ©** des mises Ã  jour sans attendre la rÃ©ponse serveur.  
- Meilleure **expÃ©rience utilisateur** (rÃ©activitÃ© accrue).  
- Evite les **flashs** de chargement entre lâ€™envoi et la mise Ã  jour rÃ©elle.  

âŒ **Sans `useOptimistic`** :  
- Lâ€™interface attend la rÃ©ponse serveur avant de sâ€™actualiser â†’ latence perÃ§ue.  
- Besoin de **rafraÃ®chir les donnÃ©es** via `revalidatePath()` aprÃ¨s chaque mutation.  

---

## **2ï¸âƒ£ Exemple : Liste de tÃ¢ches avec mise Ã  jour optimiste**  

Nous allons crÃ©er une application de gestion de tÃ¢ches avec :  
1ï¸âƒ£ Un affichage **en temps rÃ©el** des tÃ¢ches.  
2ï¸âƒ£ Une suppression optimiste avant confirmation serveur.  

---

### **ğŸ“Œ Ã‰tape 1 : Server Actions pour rÃ©cupÃ©rer et supprimer une tÃ¢che**  

```tsx filename="app/actions/todos.ts" copy
"use server";

import { db } from "@/lib/db";
import { revalidatePath } from "next/cache";

// RÃ©cupÃ©rer les tÃ¢ches
export async function getTodos() {
  return await db.todo.findMany();
}

// Supprimer une tÃ¢che
export async function deleteTodo(id: string) {
  await db.todo.delete({ where: { id } });

  // Forcer la mise Ã  jour cÃ´tÃ© serveur
  revalidatePath("/todos");
}
```

âœ… **Explication** :  
- `getTodos()` rÃ©cupÃ¨re les tÃ¢ches.  
- `deleteTodo()` supprime une tÃ¢che et **rafraÃ®chit automatiquement** la liste.  

---

### **ğŸ“Œ Ã‰tape 2 : Affichage avec `useOptimistic`**  

```tsx filename="app/todos/page.tsx" copy
"use client";

import { useOptimistic, useState } from "react";
import { getTodos, deleteTodo } from "@/app/actions/todos";

export default function TodosPage() {
  const [todos, setTodos] = useState(await getTodos());

  // ğŸ¯ Utilisation de `useOptimistic`
  const [optimisticTodos, setOptimisticTodos] = useOptimistic(
    todos, // Valeur initiale
    (currentTodos, idToRemove) => currentTodos.filter(todo => todo.id !== idToRemove)
  );

  async function handleDelete(id: string) {
    // Mise Ã  jour immÃ©diate de la liste (optimiste)
    setOptimisticTodos(id);
    
    // Envoi rÃ©el au serveur
    await deleteTodo(id);
  }

  return (
    <div className="max-w-md mx-auto p-4 border rounded-lg shadow-lg">
      <h1 className="text-xl font-bold mb-4">Liste des tÃ¢ches</h1>
      <ul>
        {optimisticTodos.map((todo) => (
          <li key={todo.id} className="flex justify-between border-b py-2">
            {todo.title}
            <button 
              onClick={() => handleDelete(todo.id)}
              className="text-red-500"
            >
              âœ–
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

âœ… **Explication** :  
- `useOptimistic(todos, callback)` permet de **supprimer immÃ©diatement une tÃ¢che** de la liste.  
- **DÃ¨s le clic**, la tÃ¢che disparaÃ®t **avant mÃªme** que `deleteTodo()` soit exÃ©cutÃ©.  
- Si la suppression Ã©choue, on peut gÃ©rer un rollback (ex. afficher un message dâ€™erreur).  

---

## **3ï¸âƒ£ Comparaison : `useOptimistic` vs `revalidatePath`**  

| ğŸ”¹ MÃ©thode | `useOptimistic` | `revalidatePath` |
|------------|----------------|----------------|
| ğŸ¯ **Effet** | Mise Ã  jour immÃ©diate | RafraÃ®chit la page aprÃ¨s mutation |
| âš¡ **Performance** | InstantanÃ© | Plus lent (attend la rÃ©ponse serveur) |
| ğŸ”„ **ExpÃ©rience utilisateur** | Ultra rÃ©actif | Parfois des flashs de chargement |
| âœ… **Utilisation idÃ©ale** | Modifications visuelles rapides | DonnÃ©es critiques nÃ©cessitant une revalidation |

---

## **4ï¸âƒ£ GÃ©rer les erreurs (rollback en cas dâ€™Ã©chec)**  

Que se passe-t-il si la suppression Ã©choue ?  
On peut ajouter une gestion dâ€™erreur avec un rollback.  

```tsx filename="handleDelete()" copy
async function handleDelete(id: string) {
  const previousTodos = optimisticTodos; // Sauvegarde
  
  setOptimisticTodos(id); // Suppression instantanÃ©e

  try {
    await deleteTodo(id);
  } catch (error) {
    setOptimisticTodos(previousTodos); // Rollback en cas d'erreur
  }
}
```

âœ… **Si `deleteTodo(id)` Ã©choue**, la tÃ¢che rÃ©apparaÃ®t immÃ©diatement.  

---

## **ğŸ¯ Conclusion : Pourquoi `useOptimistic` est un game-changer ?**  

ğŸš€ **Avec `useOptimistic`**, lâ€™UI devient ultra-fluide :  
âœ… **Moins de latence perÃ§ue** â†’ meilleures performances UX.  
âœ… **Moins de re-rendering** inutile.  
âœ… **Gestion fine des mutations** sans bloquer lâ€™interface.