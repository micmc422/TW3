# ğŸš€ **Gestion des mutations avec `useTransition()` dans Next.js 13+**  

Lorsqu'on effectue des mutations (ajout, suppression, mise Ã  jour de donnÃ©es), il est crucial d'assurer une bonne **expÃ©rience utilisateur** sans ralentir l'interface.  
ğŸ‘‰ Câ€™est lÃ  que **`useTransition()`** entre en jeu !  

---

## **ğŸ“Œ 1ï¸âƒ£ Pourquoi utiliser `useTransition()` ?**  

âœ… **Avantages** :  
- EmpÃªche le **blocage de lâ€™interface** lors des mutations.  
- Permet d'afficher un **Ã©tat de chargement lÃ©ger**.  
- OptimisÃ© pour **les interactions non critiques** (ex: soumission d'un formulaire).  
- Compatible avec **les Server Actions**.  

âŒ **Sans `useTransition()`** :  
- **Lâ€™UI se fige** lors dâ€™une action lourde (ex: envoi dâ€™un formulaire).  
- Lâ€™expÃ©rience utilisateur est dÃ©gradÃ©e sur des rÃ©seaux lents.  

---

## **ğŸ“Œ 2ï¸âƒ£ Exemple : Ajouter une tÃ¢che avec `useTransition()`**  

Nous allons implÃ©menter un formulaire d'ajout de tÃ¢che qui :  
1ï¸âƒ£ EmpÃªche le blocage du bouton lors de l'envoi.  
2ï¸âƒ£ Affiche un **Ã©tat de chargement** temporaire.  

---

### **ğŸŒ Ã‰tape 1 : Mise Ã  jour de lâ€™action serveur**  

ğŸ›  **Fichier : `app/actions/todos.ts`**  
```tsx
"use server";

import { db } from "@/lib/db";
import { revalidatePath } from "next/cache";

export async function addTodo(title: string) {
  if (!title) return { error: "Le titre est requis" };

  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simule un dÃ©lai rÃ©seau
  
  await db.todo.create({ data: { title } });

  revalidatePath("/todos"); // RafraÃ®chit la page
  return { success: "TÃ¢che ajoutÃ©e !" };
}
```

âœ… **Ajout dâ€™un `setTimeout()`** pour simuler une requÃªte lente.  

---

### **ğŸ“Œ Ã‰tape 2 : Utilisation de `useTransition()` dans le formulaire**  

ğŸ›  **Fichier : `app/todos/AddTodoForm.tsx`**  
```tsx
"use client";

import { useState, useTransition } from "react";
import { addTodo } from "@/app/actions/todos";

export default function AddTodoForm() {
  const [title, setTitle] = useState("");
  const [isPending, startTransition] = useTransition(); // ğŸ”¥ useTransition

  async function handleSubmit(event: React.FormEvent) {
    event.preventDefault();
    
    startTransition(async () => {
      const result = await addTodo(title);
      if (result?.success) setTitle(""); // RÃ©initialise le champ en cas de succÃ¨s
    });
  }

  return (
    <form onSubmit={handleSubmit} className="mt-4 space-y-3">
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Nouvelle tÃ¢che"
        className="w-full p-2 border rounded"
        required
      />
      <button 
        type="submit"
        disabled={isPending} 
        className={`w-full py-2 rounded ${isPending ? "bg-gray-400" : "bg-green-500 text-white"}`}
      >
        {isPending ? "Ajout..." : "Ajouter"}
      </button>
    </form>
  );
}
```

âœ… **Explication** :  
- `useTransition()` crÃ©e un Ã©tat **`isPending`** qui devient `true` pendant la mutation.  
- `startTransition(callback)` exÃ©cute **la mutation sans bloquer l'interface**.  
- Le bouton devient **dÃ©sactivÃ© (`disabled`)** et affiche `"Ajout..."` pendant le traitement.  

---

## **ğŸ“Œ 3ï¸âƒ£ Comparaison : `useTransition()` vs `useState()`**  

| ğŸ”¹ MÃ©thode | `useTransition()` | `useState()` |
|------------|----------------|----------------|
| ğŸ¯ **Effet** | Laisse l'UI rÃ©active | Peut bloquer l'UI |
| âš¡ **Performance** | Mutation non bloquante | Risque de lag |
| ğŸ”„ **Utilisation idÃ©ale** | Formulaires, interactions lÃ©gÃ¨res | Chargement global, mises Ã  jour frÃ©quentes |

---

## **ğŸ“Œ 4ï¸âƒ£ Exemple avancÃ© : Combiner `useOptimistic` et `useTransition()`**  

On peut **combiner** `useOptimistic()` et `useTransition()` pour une UX **fluide et instantanÃ©e** !  

ğŸ›  **Fichier : `app/todos/page.tsx`**  
```tsx
"use client";

import { useOptimistic, useTransition, useState } from "react";
import { getTodos, addTodo } from "@/app/actions/todos";

export default function TodosPage() {
  const [todos, setTodos] = useState(await getTodos());
  const [isPending, startTransition] = useTransition();

  const [optimisticTodos, setOptimisticTodos] = useOptimistic(
    todos,
    (currentTodos, newTodo) => [...currentTodos, newTodo] // Ajout instantanÃ©
  );

  function handleAdd(title: string) {
    const newTodo = { id: Date.now().toString(), title }; // Ajout optimiste

    setOptimisticTodos(newTodo); // Mise Ã  jour instantanÃ©e

    startTransition(async () => {
      await addTodo(title); // Envoi rÃ©el
    });
  }

  return (
    <div className="max-w-md mx-auto p-4 border rounded-lg shadow-lg">
      <h1 className="text-xl font-bold mb-4">Liste des tÃ¢ches</h1>
      <ul>
        {optimisticTodos.map((todo) => (
          <li key={todo.id} className="border-b py-2">{todo.title}</li>
        ))}
      </ul>
      <AddTodoForm onAdd={handleAdd} isPending={isPending} />
    </div>
  );
}
```

ğŸ›  **Fichier : `app/todos/AddTodoForm.tsx`**  
```tsx
"use client";

import { useState } from "react";

export default function AddTodoForm({ onAdd, isPending }: { onAdd: (title: string) => void, isPending: boolean }) {
  const [title, setTitle] = useState("");

  function handleSubmit(event: React.FormEvent) {
    event.preventDefault();
    onAdd(title);
    setTitle("");
  }

  return (
    <form onSubmit={handleSubmit} className="mt-4 space-y-3">
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Nouvelle tÃ¢che"
        className="w-full p-2 border rounded"
        required
      />
      <button 
        type="submit"
        disabled={isPending} 
        className={`w-full py-2 rounded ${isPending ? "bg-gray-400" : "bg-green-500 text-white"}`}
      >
        {isPending ? "Ajout..." : "Ajouter"}
      </button>
    </form>
  );
}
```

âœ… **Effet combinÃ©** :  
- `useOptimistic()` affiche **instantanÃ©ment** la nouvelle tÃ¢che.  
- `useTransition()` Ã©vite de **bloquer lâ€™interface** pendant lâ€™envoi rÃ©el.  

---

## **ğŸ¯ Conclusion : Pourquoi utiliser `useTransition()` ?**  

ğŸš€ **Avec `useTransition()`, l'expÃ©rience utilisateur est optimisÃ©e** :  
âœ… **Mutation fluide** â†’ Aucune latence perÃ§ue.  
âœ… **Interface toujours rÃ©active** â†’ Pas de blocage des boutons.  
âœ… **Facile Ã  intÃ©grer avec `useOptimistic()`** â†’ Interactions instantanÃ©es.  

