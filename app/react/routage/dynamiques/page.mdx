# ğŸ§± Routes Dynamiques & ParamÃ¨tres

Les **routes dynamiques** permettent d'afficher un contenu en fonction de segments variables de l'<Term word="URL">URL</Term> (ex: `/produits/A1`, `/users/42`). On utilise la syntaxe `:param` dans le chemin et le <Term word="hook">hook</Term> `useParams()` pour rÃ©cupÃ©rer les valeurs.

## ğŸ§  Fondamentaux
Une route dynamique = chemin avec segment paramÃ©trÃ© `:id` + <Term word="composant">composant</Term> qui lit la valeur. Avantages :
1. URL sÃ©mantiques et partageables
2. Navigation cÃ´tÃ© client rapide (<Term word="SPA">SPA</Term>)
3. Chargement ciblÃ© de donnÃ©es (fetch selon ID)

### ğŸ“¦ Exemple minimal
```jsx copy
import { BrowserRouter, Routes, Route, useParams } from 'react-router';

function Product() {
  const { id } = useParams();
  return <p>Produit #{id}</p>;
}

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/product/:id" element={<Product />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### ğŸ” ParamÃ¨tres multiples
```jsx copy
<Route path="/shop/:category/:sku" element={<Item />} />

function Item() {
  const { category, sku } = useParams();
  return <p>{category} â€“ rÃ©fÃ©rence {sku}</p>;
}
```

### ğŸ•¸ï¸ Recherche (Query string)
Les paramÃ¨tres d'URL ne couvrent pas tout. Pour une pagination ou un tri : utiliser l'<Term word="API">API</Term> `URLSearchParams` sur `window.location.search` ou `useSearchParams()`.
```jsx copy
import { useSearchParams } from 'react-router';

function ProductsList() {
  const [searchParams, setSearchParams] = useSearchParams();
  const page = searchParams.get('page') ?? '1';

  return (
    <div>
      <p>Page {page}</p>
      <button onClick={() => setSearchParams({ page: Number(page) + 1 })}>Suivant</button>
    </div>
  );
}
```

### ğŸªœ Routes imbriquÃ©es + paramÃ¨tres
On peut imbriquer une route paramÃ©trÃ©e et des sousâ€‘vues (ex: `/users/:id/settings`).
```jsx copy
import { BrowserRouter, Routes, Route, Outlet, useParams } from 'react-router';

function UserLayout() {
  const { id } = useParams();
  return (
    <div>
      <h2>Utilisateur {id}</h2>
      <Outlet />
    </div>
  );
}
function Profile() { return <p>Profil</p>; }
function Preferences() { return <p>PrÃ©fÃ©rences</p>; }

export function AppNestedParams() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/users/:id" element={<UserLayout />}> 
          <Route path="profile" element={<Profile />} />
          <Route path="preferences" element={<Preferences />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

### ğŸƒ Wildcard / Catch-all
Pour gÃ©rer routes non dÃ©finies ou segments supplÃ©mentaires.
```jsx copy
<Route path="/docs/*" element={<Docs />} />
```
Dans `Docs`, vous pouvez analyser `location.pathname` pour router manuellement ou charger un article par slug.

### ğŸš« 404 (Not Found)
Toujours prÃ©voir une route de repli.
```jsx copy
<Route path="*" element={<p>Page introuvable</p>} />
```

### ğŸ›¡ï¸ Validation d'ID
Ne faites pas confiance directement Ã  `id`. VÃ©rifiez format (regex) avant de lancer un fetch.
```jsx copy
function Product() {
  const { id } = useParams();
  if (!/^\w{2,10}$/.test(id)) return <p>ID invalide</p>;
  return <p>Produit #{id}</p>;
}
```

### ğŸ’¤ Lazy + paramÃ¨tre
Combiner <Term word="lazy loading">lazy loading</Term> pour vues spÃ©cialisÃ©es.
```jsx copy
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router';

const Product = lazy(() => import('./Product'));

export function AppLazyDynamic() {
  return (
    <BrowserRouter>
      <Suspense fallback={<p>Chargementâ€¦</p>}>
        <Routes>
          <Route path="/product/:id" element={<Product />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

## ğŸ› ï¸ Exercices
1. CrÃ©e `/articles/:slug` et affiche le slug formatÃ© (remplacer `-` par espaces capitalisÃ©s).  
2. Ajoute pagination via `?page=` avec `useSearchParams()`.  
3. Ajoute une route catchâ€‘all `/articles/*` qui affiche Â« Archive Â» pour tout chemin non spÃ©cifique.  
4. Valide le slug avec regex (`^[a-z0-9-]+$`).

```jsx copy
// Fichier: src/App.jsx
import { BrowserRouter, Routes, Route, useParams, useSearchParams } from 'react-router';

function Article() {
  const { slug } = useParams();
  if (!/^[a-z0-9-]+$/.test(slug)) return <p>Slug invalide</p>;
  const title = slug.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
  return <h2>{title}</h2>;
}
function ArticlesIndex() {
  const [sp, setSp] = useSearchParams();
  const page = sp.get('page') ?? '1';
  return (
    <div>
      <p>Page {page}</p>
      <button onClick={() => setSp({ page: String(Number(page) + 1) })}>Suivant</button>
    </div>
  );
}
function Archive() { return <p>Archive des articles</p>; }

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/articles" element={<ArticlesIndex />} />
        <Route path="/articles/:slug" element={<Article />} />
        <Route path="/articles/*" element={<Archive />} />
        <Route path="*" element={<p>404</p>} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

## ğŸ“š Ressources
- Docs officielle paramÃ¨tres : https://reactrouter.com/en/main/hooks/use-params
- Recherche / query : https://reactrouter.com/en/main/hooks/use-search-params
- Wildcards & patterns : https://reactrouter.com/en/main/route/route

---

## âš¡ TLDR
- ParamÃ¨tres : `:id` + `useParams()`
- Query string : `useSearchParams()` pour lire/Ã©crire
- Imbrication avec paramÃ¨tre : parent + `<Outlet />`
- Catch-all : `*` pour 404 ou wildcard
- Valider / sÃ©curiser les identifiants avant fetch
- Lazy sur vues lourdes paramÃ©trÃ©es

---

Voir aussi : /react/routage pour la vue dâ€™ensemble et /react/donnees pour le chargement cÃ´tÃ© client.