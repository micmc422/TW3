import { Callout } from 'nextra/components'

# RÃ¨gles des Hooks en React

React a introduit les Hooks dans sa version 16.8 pour permettre aux dÃ©veloppeurs d'utiliser l'Ã©tat et d'autres fonctionnalitÃ©s de React sans avoir Ã  Ã©crire des classes. Cependant, il y a certaines rÃ¨gles strictes que vous devez suivre lors de l'utilisation des Hooks. Voici ces rÃ¨gles:

## 1. Ne pas appeler les Hooks Ã  l'intÃ©rieur des boucles, des conditions ou des fonctions imbriquÃ©es

**Il est important de toujours appeler les Hooks au niveau supÃ©rieur de vos fonctions de composant ou de vos fonctions personnalisÃ©es.** Vous ne devez jamais les appeler Ã  l'intÃ©rieur des boucles, des conditions ou des fonctions imbriquÃ©es. Cela garantit que les Hooks sont appelÃ©s dans le mÃªme ordre chaque fois qu'un composant est rendu, ce qui permet Ã  React de maintenir correctement l'Ã©tat entre plusieurs appels de Hooks.
Voici deux exemples :  

### âœ… **Exemple Valide** (Respecte les rÃ¨gles des Hooks)  
```jsx
import { useState, useEffect } from "react";

function ValidComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Le compteur a changÃ© :", count);
  }, [count]);

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
    </div>
  );
}
```
ğŸ‘‰ Ici, `useState` et `useEffect` sont appelÃ©s directement au dÃ©but de la fonction, garantissant qu'ils s'exÃ©cutent dans le mÃªme ordre Ã  chaque rendu.

---

### âŒ **Exemple Invalide** (Ne respecte pas les rÃ¨gles des Hooks)  
```jsx
import { useState, useEffect } from "react";

function InvalidComponent() {
  const [count, setCount] = useState(0);

  if (count > 5) {
    const [otherState, setOtherState] = useState("Erreur"); // âŒ Mauvaise pratique !
  }

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
    </div>
  );
}
```
ğŸš¨ **ProblÃ¨me** :  
- `useState("Erreur")` est appelÃ© dans une condition (`if (count > 5)`).  
- Cela casse l'ordre d'exÃ©cution des Hooks, car React s'attend Ã  ce que chaque Hook soit toujours appelÃ© dans le mÃªme ordre Ã  chaque rendu du composant.  

## 2. Appeler les Hooks uniquement Ã  partir de fonctions de composant ou de fonctions personnalisÃ©es

**Les Hooks ne peuvent Ãªtre appelÃ©s que depuis des fonctions de composant React ou des fonctions personnalisÃ©es.** Vous ne pouvez pas les appeler Ã  partir de fonctions JavaScript rÃ©guliÃ¨res. De plus, ils ne peuvent pas Ãªtre appelÃ©s Ã  partir de fonctions de classe.
Voici deux exemples illustrant cette rÃ¨gle :  

---

### âœ… **Exemple Valide** (Les Hooks sont utilisÃ©s dans un composant fonctionnel)  
```jsx
import { useState, useEffect } from "react";

function ValidComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Compteur mis Ã  jour :", count);
  }, [count]);

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
    </div>
  );
}
```
âœ… **Pourquoi c'est valide ?**  
- `useState` et `useEffect` sont appelÃ©s dans un composant fonctionnel (`ValidComponent`).  
- React peut gÃ©rer correctement l'Ã©tat et le cycle de vie du composant.

---

### âŒ **Exemple Invalide** (Un Hook est appelÃ© dans une fonction classique)  
```jsx
import { useState } from "react";

function badFunction() {
  const [count, setCount] = useState(0); // âŒ ERREUR : useState ne peut pas Ãªtre utilisÃ© ici
  return count;
}

function InvalidComponent() {
  return <p>Valeur : {badFunction()}</p>;
}
```
ğŸš¨ **ProblÃ¨me** :  
- `badFunction` est une fonction JavaScript classique, **pas un composant React**.  
- Les Hooks **ne peuvent Ãªtre appelÃ©s que dans des composants fonctionnels** ou des Hooks personnalisÃ©s.  

---

### âœ… **Correction avec un Hook personnalisÃ©**  
Si vous voulez rÃ©utiliser la logique d'un Hook, il faut crÃ©er un **Hook personnalisÃ©** (une fonction qui commence par `use` et utilise des Hooks en interne).  

```jsx
import { useState } from "react";

// âœ… Un Hook personnalisÃ© commence par "use"
function useCounter() {
  const [count, setCount] = useState(0);
  return { count, setCount };
}

function ValidComponent() {
  const { count, setCount } = useCounter(); // Utilisation du Hook personnalisÃ©

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
    </div>
  );
}
```
âœ… **Pourquoi c'est valide ?**  
- `useCounter` est un **Hook personnalisÃ©**, donc il peut utiliser `useState`.  
- `useCounter` est **appelÃ© dans un composant fonctionnel**, ce qui respecte les rÃ¨gles de React.  

---

### âŒ **Exemple Invalide avec une Classe** (Les Hooks ne fonctionnent pas dans les classes)  
```jsx
import { useState } from "react";

class InvalidClassComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    const [count, setCount] = useState(0); // âŒ ERREUR : Impossible d'utiliser un Hook dans une classe
    return (
      <div>
        <p>Compteur : {count}</p>
        <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
      </div>
    );
  }
}
```
ğŸš¨ **ProblÃ¨me** :  
- Les **composants de classe** utilisent `this.state` et `this.setState()`, pas les Hooks.  
- `useState` **ne peut pas Ãªtre utilisÃ© dans une classe**.  

---

### âœ… **Correction avec un Composant Fonctionnel**  
Si vous utilisez React moderne, il est recommandÃ© d'utiliser des **composants fonctionnels avec des Hooks** Ã  la place des classes :  
```jsx
import { useState } from "react";

function ValidComponent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>IncrÃ©menter</button>
    </div>
  );
}
```
âœ… **Pourquoi c'est valide ?**  
- Utilisation d'un **composant fonctionnel** au lieu d'une classe.  
- `useState` est utilisÃ© **correctement au niveau supÃ©rieur du composant**.  

---

### ğŸš€ **RÃ©sumÃ© des RÃ¨gles :**  
âœ… **Les Hooks doivent Ãªtre appelÃ©s dans :**  
âœ”ï¸ Un composant fonctionnel React (`function MonComposant() {}`)  
âœ”ï¸ Un Hook personnalisÃ© (`function useMonHook() {}`)  

âŒ **Les Hooks NE DOIVENT PAS Ãªtre appelÃ©s dans :**  
âŒ Une fonction JavaScript classique (`function badFunction() {}`)  
âŒ Une classe React (`class MonComposant extends React.Component {}`)  

En suivant ces rÃ¨gles, vous Ã©vitez des erreurs et garantissez un bon fonctionnement de votre application React. ğŸ¯
## 3. Utiliser les Hooks uniquement Ã  partir de packages React

**Il est recommandÃ© d'utiliser les Hooks uniquement Ã  partir de packages React.** Bien que rien n'empÃªche techniquement de crÃ©er vos propres Hooks, il est gÃ©nÃ©ralement prÃ©fÃ©rable d'utiliser ceux fournis par React ou par des bibliothÃ¨ques tierces fiables. 
 <Callout type="info" emoji="â„¹ï¸">
Cela garantit que les Hooks sont compatibles avec les futures versions de React et qu'ils sont testÃ©s et maintenus par des experts.
</Callout>

En suivant ces rÃ¨gles, vous pouvez tirer pleinement parti des Hooks pour simplifier votre code et amÃ©liorer la rÃ©utilisabilitÃ© de vos composants.