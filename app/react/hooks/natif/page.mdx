## **Hooks Natifs**

Voici des exemples fonctionnels pour chaque Hook natif de React :

### useState

Le Hook `useState` permet d'ajouter un √©tat local √† un composant fonctionnel. Il retourne un tableau avec deux √©l√©ments : la valeur actuelle de l'√©tat et une fonction pour la mettre √† jour.

```jsx copy
import React, { useState } from 'react';

function Counter() {
 const [count, setCount] = useState(0);
 return (
   <div>
     <p>Vous avez cliqu√© {count} fois</p>
     <button onClick={() => setCount(count + 1)}>
       Click
     </button>
   </div>
 );
}
```

#### Les b√©n√©fices de la syntaxe `setCount(count => count + 1)`
```jsx copy
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); 

  return (
    <div>
      <p>Vous avez cliqu√© {count} fois</p>
      <button onClick={() => setCount(count => count + 1)}>Click</button>
    </div>
  );
}

export default Counter;
```

   **Elle garantit que l'on travaille toujours avec la valeur la plus r√©cente de l'√©tat.**  
   - React **n'applique pas imm√©diatement** les mises √† jour d'√©tat.  
   - Plusieurs mises √† jour peuvent √™tre **group√©es** pour optimiser les performances.  
   - Si une mise √† jour d√©pend de l'√©tat pr√©c√©dent, il faut utiliser la **fonction de mise √† jour** pour √©viter des erreurs.  

   ‚úÖ **Exemple o√π cette syntaxe est indispensable** :  
   ```jsx copy
   function Counter() {
     const [count, setCount] = useState(0);

     const incrementThreeTimes = () => {
       setCount(count + 1); // ‚ùå Ne prend pas en compte les mises √† jour group√©es
       setCount(count + 1);
       setCount(count + 1);
     };

     return (
       <div>
         <p>Compteur : {count}</p>
         <button onClick={incrementThreeTimes}>+3</button>
       </div>
     );
   }
   ```
   üî¥ **Probl√®me :**  
   - Tu t'attends √† ce que `count` augmente de 3, mais en r√©alit√©, il **n'augmente que de 1**.  
   - Chaque `setCount(count + 1)` lit la m√™me valeur de `count` (celle du rendu actuel).  
   - Les mises √† jour sont **√©cras√©es** car React ne met pas √† jour imm√©diatement `count`.  

   ‚úÖ **Correction avec la fonction de mise √† jour** :  
   ```jsx copy
   const incrementThreeTimes = () => {
     setCount(prevCount => prevCount + 1);
     setCount(prevCount => prevCount + 1);
     setCount(prevCount => prevCount + 1);
   };
   ```
   üéØ **R√©sultat :** `count` augmente bien de 3, car chaque `setCount` re√ßoit la **valeur mise √† jour** de l'√©tat.  

---

2. **Elle fonctionne mieux avec les effets (`useEffect`) et les mises √† jour asynchrones.**  
   ```jsx copy
   useEffect(() => {
     setTimeout(() => {
       setCount(prevCount => prevCount + 1);
     }, 1000);
   }, []);
   ```
   ‚úÖ **Pourquoi ?**  
   - Si `setTimeout` s'ex√©cute apr√®s plusieurs secondes, `prevCount` garantit qu'on **utilise bien la derni√®re valeur de l'√©tat**, peu importe les autres mises √† jour.  
   - Avec `setCount(count + 1)`, on risquerait d'utiliser une **valeur p√©rim√©e** si d'autres mises √† jour ont eu lieu entre-temps.

---

#### R√©sum√© des b√©n√©fices
‚úÖ **S√©curis√© contre les mises √† jour group√©es** (√©vite l'√©crasement d'√©tat).  
‚úÖ **Indispensable pour les mises √† jour successives (`+1` plusieurs fois d'affil√©e).**  
‚úÖ **Fiable avec des effets (`useEffect`) et les mises √† jour asynchrones.**  

‚û°Ô∏è **Bonne pratique :** Toujours utiliser `setCount(prev => prev + 1)` quand la mise √† jour d√©pend de l'√©tat pr√©c√©dent ! üî•
### useEffect

Le Hook `useEffect` permet d'effectuer des effets secondaires dans les composants fonctionnels. Il peut √™tre utilis√© pour des op√©rations telles que les requ√™tes r√©seau, les abonnements, les manipulations du DOM, etc.

```jsx copy
import React, { useState, useEffect } from 'react';

function Exemple() {
  const [count, setCount] = useState(0);

  // Similaire √† componentDidMount et componentDidUpdate :
  useEffect(() => {
    // Met √† jour le titre du document en utilisant l'API du navigateur
    document.title = `Vous avez cliqu√© ${count} fois`;
  });

  return (
    <div>
      <p>Vous avez cliqu√© {count} fois</p>
      <button onClick={() => setCount(count + 1)}>
        Cliquez-moi
      </button>
    </div>
  );
}

export default Exemple;

```
#### **L‚Äôutilit√© du `return` dans `useEffect`**  

Le `return` dans `useEffect` est utilis√© pour **nettoyer les effets secondaires** lorsqu‚Äôun composant est d√©mont√© ou avant la prochaine ex√©cution de l‚Äôeffet. C‚Äôest ce qu‚Äôon appelle une **fonction de nettoyage** (*cleanup function*).  

---

#### **Exemple sans `return` (effet simple)**
```jsx copy
import React, { useState, useEffect } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Le composant est mont√© ou mis √† jour.");
  });

  return (
    <div>
      <p>Compteur : {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Timer;
```
‚úÖ Ici, `useEffect` est ex√©cut√© √† **chaque rendu**, mais il n‚Äôy a **pas de nettoyage**.  

---

#### **Pourquoi utiliser un `return` dans `useEffect` ?**
La fonction de nettoyage est utile dans plusieurs cas :
1. **√âviter les fuites de m√©moire** (ex. `setInterval`, `setTimeout`).
2. **D√©sabonner un √©couteur d‚Äô√©v√©nement (`addEventListener`).**
3. **Annuler une requ√™te HTTP ou une WebSocket.**

---

#### **Exemple avec nettoyage (`return`)**
```jsx copy
import React, { useState, useEffect } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("D√©marrage du timer...");
    const interval = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);

    // Fonction de nettoyage
    return () => {
      console.log("Arr√™t du timer !");
      clearInterval(interval);
    };
  }, []); // Ex√©cuter une seule fois au montage

  return <p>Compteur : {count}</p>;
}

export default Timer;
```

‚úÖ **Explication :**  
- Quand le composant est **mont√©**, on d√©marre un `setInterval()`.  
- Quand le composant est **d√©mont√©**, la fonction retourn√©e s‚Äôex√©cute et **arr√™te le timer** (`clearInterval`).  
- **Sans le `return`**, le timer continuerait √† tourner m√™me apr√®s que le composant soit retir√© du DOM, causant une **fuite de m√©moire**.  

---

#### **Exemple avec `addEventListener`**
Si on ajoute un √©couteur d‚Äô√©v√©nement sans le retirer, il peut continuer √† exister apr√®s le d√©montage du composant :

‚ùå **Mauvais exemple (pas de nettoyage)**
```jsx copy
useEffect(() => {
  window.addEventListener("resize", () => {
    console.log("Fen√™tre redimensionn√©e !");
  });
}, []); // Ajout une seule fois, mais jamais retir√© !
```
üî¥ **Probl√®me** :  
- L‚Äô√©v√©nement `resize` reste actif m√™me apr√®s le d√©montage du composant.  

‚úÖ **Solution avec un `return` pour le supprimer :**
```jsx copy
useEffect(() => {
  const handleResize = () => {
    console.log("Fen√™tre redimensionn√©e !");
  };

  window.addEventListener("resize", handleResize);

  return () => {
    console.log("Suppression de l'√©couteur !");
    window.removeEventListener("resize", handleResize);
  };
}, []);
```
üëâ **R√©sultat :** L‚Äô√©couteur est supprim√© quand le composant est d√©mont√©, **√©vite les bugs et les fuites m√©moire**.

---

#### **R√©sum√© :**
1. **Le `return` dans `useEffect` sert √† nettoyer les effets secondaires** avant le d√©montage du composant ou avant l‚Äôex√©cution du prochain effet.  
2. Il est indispensable pour :
   - **`setInterval()` / `setTimeout()`** ‚Üí (`clearInterval()` / `clearTimeout()`)
   - **√âcouteurs d‚Äô√©v√©nements (`addEventListener`)** ‚Üí (`removeEventListener`)
   - **WebSockets ou requ√™tes API** ‚Üí (`abort()`)
3. **Sans ce nettoyage, on risque des fuites m√©moire ou des comportements ind√©sirables.**  

‚û°Ô∏è **R√®gle d‚Äôor :** **Si un effet met en place quelque chose de persistant (timer, √©couteur...), il doit √™tre nettoy√© avec `return` !** üöÄ
### useContext

Le Hook `useContext` permet d'acc√©der √† la valeur actuelle d'un contexte. Il est souvent utilis√© avec le Context API pour partager des donn√©es globales entre plusieurs composants.

```jsx copy
import React, { useContext } from 'react';

// Cr√©ation d'un contexte avec une valeur par d√©faut "light"
const ThemeContext = React.createContext('light');

function BoutonTh√®me() {
  // Utilisation du contexte pour r√©cup√©rer la valeur actuelle du th√®me
  const theme = useContext(ThemeContext);

  return <button theme={theme}>Je suis stylis√© par le contexte du th√®me !</button>;
}

export default BoutonTh√®me;
```

### useReducer

Le Hook `useReducer` est une alternative √† `useState` qui est plus adapt√©e pour g√©rer des logiques d'√©tat complexes. Il fonctionne de mani√®re similaire √† `reduce` dans JavaScript, en acceptant un r√©ducteur et un √©tat initial.

```jsx copy
import React, { useReducer } from 'react';

// √âtat initial du compteur
const √©tatInitial = { count: 0 };

// Fonction r√©ductrice (reducer) pour g√©rer les actions
function r√©ducteur(√©tat, action) {
  switch (action.type) {
    case 'incrementer':
      return { count: √©tat.count + 1 };
    case 'decrementer':
      return { count: √©tat.count - 1 };
    default:
      throw new Error('Action non reconnue');
  }
}

function Compteur() {
  // useReducer permet de g√©rer l'√©tat avec un reducer
  const [√©tat, dispatch] = useReducer(r√©ducteur, √©tatInitial);

  return (
    <>
      <p>Compteur : {√©tat.count}</p>
      <button onClick={() => dispatch({ type: 'decrementer' })}>-</button>
      <button onClick={() => dispatch({ type: 'incrementer' })}>+</button>
    </>
  );
}

export default Compteur;
```

### useRef

Le Hook `useRef` permet de cr√©er une r√©f√©rence mutable qui persiste pendant toute la dur√©e de vie du composant. Il est souvent utilis√© pour acc√©der aux √©l√©ments du DOM ou pour garder une r√©f√©rence √† une valeur qui peut changer au fil du temps.

```jsx copy
import React, { useRef } from 'react';

function TextInputWithFocusButton() {
 const inputEl = useRef(null);
 const onButtonClick = () => {
   // `current` pointe vers le champ de saisie mont√© dans le DOM
   inputEl.current.focus();
 };
 return (
   <>
     <input ref={inputEl} type="text" />
     <button onClick={onButtonClick}>Focus the input</button>
   </>
 );
}
```

### useMemo

Le Hook `useMemo` permet de m√©moriser des calculs co√ªteux. Il retourne une valeur m√©moris√©e qui ne change que si une de ses d√©pendances change.

```jsx copy
import React, { useMemo } from 'react';

function computeExpensiveValue(a, b) {
 // Simule un calcul co√ªteux
 let result = 0;
 for (let i = 0; i < 1000000000; i++) {
   result += a * b;
 }
 return result;
}

function MyComponent({ a, b }) {
 const expensiveValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
 // ...
}
```

### useCallback

Le Hook `useCallback` permet de m√©moriser une fonction. Il retourne une version m√©moris√©e de la fonction qui ne change que si une de ses d√©pendances change.

```jsx copy
import React, { useCallback } from 'react';

function MyComponent({ a, b }) {
 const memoizedCallback = useCallback(
   () => {
     doSomething(a, b);
   },
   [a, b],
 );
 // ...
}
```

Dans cet exemple, `memoizedCallback` est une version m√©moris√©e de la fonction qui ne change que si `a` ou `b` change.