# üß† State et cycle de vie des composants (explications approfondies)

Le <Term word="state">state</Term> est la donn√©e locale propre √† un <Term word="composant">composant</Term> <Term word="React">React</Term>. Quand le state change, React re-renderise le composant (et ses enfants si n√©cessaire) pour mettre √† jour l'interface.

Cette page explique :
- comment utiliser `useState` et `useReducer` pour g√©rer l'√©tat ;
- comment manipuler des objets et tableaux d'√©tat de fa√ßon immuable ;
- comment `useEffect` remplace les m√©thodes de cycle de vie des classes ;
- bonnes pratiques et pi√®ges courants (batching, valeurs asynchrones, initialisation paresseuse).

### Exemple basique avec useState

```jsx copy
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0); // √©tat initial = 0

  return (
    <div>
      <p>Vous avez cliqu√© {count} fois</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

Explications :
- `useState(0)` cr√©e un √©tat `count` initialis√© √† `0` et retourne `[count, setCount]`.
- `setCount` remplace la valeur de `count` (pas de fusion automatique comme pour `this.setState` en classes). Pour modifier en fonction de la valeur pr√©c√©dente, utilisez la forme fonctionnelle (voir ci-dessous).

### Mise √† jour bas√©e sur l'√©tat pr√©c√©dent (forme fonctionnelle)

Lorsque la nouvelle valeur d√©pend de l'ancienne, pr√©f√©rez :

```jsx copy
setCount(prev => prev + 1);
```

Pourquoi ?
- React peut regrouper (batch) les mises √† jour d'√©tat. Si vous √©crivez `setCount(count + 1)` plusieurs fois dans la m√™me phase, toutes les lectures de `count` peuvent correspondre √† l'ancienne valeur et produire un r√©sultat inattendu. En passant une fonction, React fournit la valeur la plus r√©cente (`prev`).

### Initialisation paresseuse

Si l'√©tat initial est co√ªteux √† calculer, vous pouvez passer une fonction √† `useState` :

```jsx copy
const [data, setData] = useState(() => expensiveInit());
```

La fonction `expensiveInit` ne sera appel√©e qu'une seule fois au montage.

### Travailler avec des objets et tableaux (immutabilit√©)

Ne muter jamais directement l'objet/array d'√©tat. Exemple : ajouter un √©l√©ment √† un tableau :

```jsx copy
const [items, setItems] = useState([]);

function add(item) {
  // Correct : cr√©er un nouveau tableau
  setItems(prev => [...prev, item]);
}

function remove(index) {
  setItems(prev => prev.filter((_, i) => i !== index));
}
```

Pour des objets :

```jsx copy
const [user, setUser] = useState({ name: 'Alice', age: 25 });

// Mettre √† jour une propri√©t√© sans √©craser les autres
setUser(prev => ({ ...prev, age: prev.age + 1 }));
```

### useReducer pour des √©tats complexes

`useReducer` est utile quand la logique d'√©tat devient complexe ou quand plusieurs sous-valeurs sont mises √† jour ensemble.

```jsx copy
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1 };
    case 'decrement':
      return { ...state, count: state.count - 1 };
    case 'reset':
      return action.payload;
    default:
      throw new Error('Action inconnue');
  }
}

export function CounterReducer() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>Compteur : {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
```

### Cycle de vie : useEffect vs m√©thodes de classe

Dans les composants de classe, on utilisait `componentDidMount`, `componentDidUpdate` et `componentWillUnmount`.
Avec les Hooks, `useEffect` couvre ces cas selon la d√©pendance fournie :

```jsx copy
import { useEffect } from 'react';

// √©quivalent de componentDidMount
useEffect(() => {
  // code de montage
}, []); // tableau vide = ex√©cute une seule fois au montage

// √©quivalent de componentDidUpdate (d√©pendances)
useEffect(() => {
  // code ex√©cut√© quand `value` change
}, [value]);

// nettoyage / componentWillUnmount
useEffect(() => {
  const id = setInterval(() => {}, 1000);
  return () => clearInterval(id); // ex√©cut√© au d√©montage
}, []);
```

Points cl√©s sur `useEffect` :
- L'effet s'ex√©cute apr√®s le rendu (<Term word="commit">commit</Term>) ; n'y mettez pas de code bloquant.
- Le tableau des d√©pendances indique quand r√©-ex√©cuter l'effet.
- Toujours d√©clarer toutes les d√©pendances n√©cessaires (ou documenter pourquoi vous les omettez).

### Batching et nature asynchrone des mises √† jour

Les appels √† `setState` (useState/setWhatever) ne mettent pas √† jour la variable locale imm√©diatement dans le m√™me rendu. React planifie la mise √† jour et re-renderise le composant. Depuis React 18, les mises √† jour sont automatiquement group√©es (batched) m√™me en dehors des gestionnaires d'√©v√©nements.

Exemple probl√©matique :

```jsx copy
setCount(count + 1);
setCount(count + 1);
// peut n'augmenter que de 1 si React batch les mises √† jour
```

Utilisez la forme fonctionnelle pour garantir le comportement attendu.

### Exemple complet comment√©

```jsx copy
import { useState, useEffect } from 'react';

export default function TodoApp() {
  const [todos, setTodos] = useState(() => {
    // initialisation paresseuse depuis le localStorage
    const raw = localStorage.getItem('todos');
    return raw ? JSON.parse(raw) : [];
  });
  const [input, setInput] = useState('');

  // sauvegarder dans localStorage quand todos change
  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  function addTodo() {
    if (!input.trim()) return;
    setTodos(prev => [...prev, { id: Date.now(), text: input }]);
    setInput('');
  }

  function removeTodo(id) {
    setTodos(prev => prev.filter(t => t.id !== id));
  }

  return (
    <div>
      <h3>Todo</h3>
      <input value={input} onChange={e => setInput(e.target.value)} />
      <button onClick={addTodo}>Ajouter</button>
      <ul>
        {todos.map(t => (
          <li key={t.id}>
            {t.text} <button onClick={() => removeTodo(t.id)}>Supprimer</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Commentaires sur l'exemple :
- Initialisation paresseuse : on lit `localStorage` une seule fois au montage.
- `useEffect` avec `[todos]` sauvegarde automatiquement l'√©tat quand il change.
- Les fonctions `addTodo` / `removeTodo` utilisent la forme fonctionnelle de `setTodos` pour √©viter les probl√®mes de concurrence.

### Quand pr√©f√©rer useReducer ?

- Lorsque l'√©tat contient plusieurs sous-valeurs li√©es (par ex. formulaire complexe).
- Quand vous voulez centraliser la logique d'√©tat (actions, reducers), ce qui facilite le test.

### Bonnes pratiques rapides

- Privil√©giez les composants fonctionnels + Hooks pour les nouveaux d√©veloppements.
- Gardez l'√©tat local aussi petit que possible : d√©rivez ce que vous pouvez.
- Ne muter jamais directement l'√©tat ; renvoyez de nouveaux objets/arrays.
- Documentez pourquoi vous omettez une d√©pendance dans `useEffect` si n√©cessaire.

## üìù TL;DR

- `useState` pour l'√©tat local simple.
- `useReducer` pour les √©tats complexes ou les transitions explicitement nomm√©es.
- `useEffect` remplace la plupart des m√©thodes de cycle de vie des classes (montage, mises √† jour, nettoyage).
- Utilisez la forme fonctionnelle `setState(prev => ...)` quand la nouvelle valeur d√©pend de l'ancienne.
- Initialisation paresseuse avec `useState(() => ...)` pour des co√ªts d'initialisation.