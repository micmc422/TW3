import Heuristiques from "./heuristiques"
import { Cards } from 'nextra/components'
import { Figma } from "lucide-react"

# ğŸ§  **Principes fondamentaux de lâ€™UX Design**  

**ğŸ¯ Objectifs du chapitre**  
- ğŸ§© Comprendre les grands principes de lâ€™UX  
- ğŸ” DÃ©couvrir les heuristiques de Nielsen et les 5 Ã©lÃ©ments de lâ€™UX  
- ğŸ§  Explorer des concepts de psychologie cognitive appliquÃ©s Ã  lâ€™UX  
- â™¿ IntÃ©grer lâ€™accessibilitÃ© et le design inclusif  


> âš¡ **TLDR** : L'UX repose sur les **10 heuristiques de Nielsen** (visibilitÃ©, cohÃ©rence, prÃ©vention d'erreursâ€¦), les **5 Ã©lÃ©ments de Garrett** (stratÃ©gie â†’ surface), les **lois cognitives** (Fitts, Hick, ProximitÃ©) et l'**accessibilitÃ©** (contraste, navigation clavier, alt text). Voir aussi : [La rÃ¨gle CRAP](/UX-UI/crap) pour les principes visuels complÃ©mentaires.
---

## ğŸ“‹ **Les 10 heuristiques de Nielsen**  

ğŸ“Œ **DÃ©finition**  
Les heuristiques de Nielsen sont des principes fondamentaux pour concevoir des interfaces intuitives et ergonomiques.  

| # | Heuristique | Explication |
|---|------------|-------------|
| 1 | VisibilitÃ© de l'Ã©tat du systÃ¨me | L'utilisateur doit savoir ce qui se passe (feedback visuel, messages de confirmation). |
| 2 | Correspondance entre le systÃ¨me et le monde rÃ©el | Utiliser des termes et concepts familiers aux utilisateurs. |
| 3 | ContrÃ´le et libertÃ© de l'utilisateur | Permettre d'annuler des actions (ex. bouton "Retour" ou "Annuler"). |
| 4 | CohÃ©rence et standards | Respecter les conventions et standards UI connus. |
| 5 | PrÃ©vention des erreurs | Ã‰viter que lâ€™utilisateur ne fasse des erreurs (confirmation avant suppression, dÃ©sactivation des options invalides). |
| 6 | Reconnaissance plutÃ´t que rappel | L'interface doit guider l'utilisateur plutÃ´t que lui demander de se souvenir. |
| 7 | FlexibilitÃ© et efficacitÃ© d'utilisation | Offrir des raccourcis et des personnalisations pour les utilisateurs avancÃ©s. |
| 8 | Design esthÃ©tique et minimaliste | Ne pas surcharger lâ€™Ã©cran, hiÃ©rarchiser lâ€™information. |
| 9 | Aide Ã  la reconnaissance et Ã  la correction des erreurs | Expliquer clairement les erreurs et comment les corriger. |
| 10 | Aide et documentation | Fournir une aide accessible en cas de besoin. |

<Heuristiques />

### ğŸ’» **Exemples concrets en React â€” Heuristiques de Nielsen**

Les exemples ci-dessous sont inspirÃ©s du projet [ma-petite-compagnie](https://github.com/JalilArfaoui/ma-petite-compagnie), une application Next.js de gestion de compagnies de thÃ©Ã¢tre.

#### ğŸ”„ Heuristique 1 â€” VisibilitÃ© de l'Ã©tat du systÃ¨me avec `useTransition`

L'utilisateur doit **toujours savoir** ce qui se passe. Lors d'une action asynchrone (envoi de formulaire, chargement), un feedback visuel est indispensable.

**âŒ Avant** : aucun feedback lors de la soumission
```tsx copy
function AjouterEvenement() {
  async function handleSubmit(formData: FormData) {
    await creerEvenement(formData); // â³ L'utilisateur ne sait pas si Ã§a marche
  }
  return (
    <form action={handleSubmit}>
      <input name="nom" placeholder="Nom de l'Ã©vÃ©nement" />
      <button type="submit">CrÃ©er</button>
    </form>
  );
}
```

**âœ… AprÃ¨s** : `useTransition` informe l'utilisateur que l'action est en cours
```tsx copy
import { useTransition } from "react";

function AjouterEvenement() {
  const [isPending, startTransition] = useTransition();

  function handleSubmit(formData: FormData) {
    startTransition(async () => {
      await creerEvenement(formData);
    });
  }
  return (
    <form action={handleSubmit}>
      <input name="nom" placeholder="Nom de l'Ã©vÃ©nement" />
      <button type="submit" disabled={isPending}>
        {isPending ? "â³ CrÃ©ation en cours..." : "CrÃ©er"}
      </button>
    </form>
  );
}
```
> ğŸ“Œ `useTransition` est un hook React 19 qui permet de marquer une mise Ã  jour comme une transition, gardant l'interface rÃ©active pendant les changements d'Ã©tat, tout en obtenant un boolÃ©en `isPending` pour afficher un Ã©tat de chargement.

#### âš¡ Heuristique 1 â€” RÃ©ponse instantanÃ©e avec `useOptimistic`

Pour les actions frÃ©quentes (like, ajout Ã  une liste), l'utilisateur attend une rÃ©ponse **immÃ©diate**. `useOptimistic` affiche le rÃ©sultat avant mÃªme la confirmation serveur.

**âŒ Avant** : l'ajout d'un participant attend la rÃ©ponse serveur
```tsx copy
function ListeParticipants({ participants }) {
  async function ajouter(formData: FormData) {
    await ajouterParticipant(formData); // â³ Latence visible
  }
  return (
    <ul>
      {participants.map(p => <li key={p.id}>{p.nom}</li>)}
    </ul>
  );
}
```

**âœ… AprÃ¨s** : l'ajout apparaÃ®t **instantanÃ©ment** dans la liste
```tsx copy
import { useOptimistic } from "react";

function ListeParticipants({ participants }) {
  const [optimisticList, addOptimistic] = useOptimistic(
    participants,
    (state, nouveau) => [...state, { ...nouveau, id: "temp", pending: true }]
  );

  async function ajouter(formData: FormData) {
    const nom = formData.get("nom");
    addOptimistic({ nom }); // âœ… Ajout instantanÃ© dans l'UI
    await ajouterParticipant(formData); // Confirmation serveur en arriÃ¨re-plan
  }

  return (
    <ul>
      {optimisticList.map(p => (
        <li key={p.id} style={{ opacity: p.pending ? 0.5 : 1 }}>
          {p.nom} {p.pending && "â³"}
        </li>
      ))}
    </ul>
  );
}
```
> ğŸ“Œ `useOptimistic` est un hook React 19 principalement utilisÃ© avec les Server Actions pour afficher instantanÃ©ment le rÃ©sultat attendu d'une mutation avant sa confirmation serveur.

#### ğŸ›¡ï¸ Heuristique 5 â€” PrÃ©vention des erreurs avec validation Zod

**âŒ Avant** : aucune validation cÃ´tÃ© client
```tsx copy
<form action={creerLieu}>
  <input name="ville" />
  <button type="submit">Enregistrer</button>
  {/* L'utilisateur peut soumettre un formulaire vide ! */}
</form>
```

**âœ… AprÃ¨s** : validation avec Zod + messages d'erreur clairs
```tsx copy
import { z } from "zod";

import { useState } from "react";

const lieuSchema = z.object({
  libelle: z.string().min(2, "Le nom doit contenir au moins 2 caractÃ¨res"),
  adresse: z.string().min(5, "Adresse trop courte"),
  ville: z.string().min(2, "Ville requise"),
});

function FormulaireCreerLieu() {
  const [errors, setErrors] = useState({});

  function handleSubmit(formData: FormData) {
    const result = lieuSchema.safeParse(Object.fromEntries(formData));
    if (!result.success) {
      setErrors(result.error.flatten().fieldErrors);
      return; // â›” EmpÃªche la soumission invalide
    }
    creerLieu(result.data);
  }

  return (
    <form action={handleSubmit}>
      <input name="libelle" placeholder="Nom du lieu" />
      {errors.libelle && <p className="text-red-500">{errors.libelle}</p>}
      <input name="adresse" placeholder="Adresse" />
      {errors.adresse && <p className="text-red-500">{errors.adresse}</p>}
      <input name="ville" placeholder="Ville" />
      {errors.ville && <p className="text-red-500">{errors.ville}</p>}
      <button type="submit">Enregistrer</button>
    </form>
  );
}
```

---

## ğŸ—ï¸ **Les 5 Ã©lÃ©ments de lâ€™UX (Jesse James Garrett)**  

ğŸ“Œ **DÃ©finition**  
Jesse James Garrett propose une approche structurÃ©e de la conception UX, divisÃ©e en 5 niveaux :  

1. ğŸ¯ **StratÃ©gie** â†’ Objectifs business & besoins des utilisateurs  
2. ğŸ“‹ **PortÃ©e** â†’ FonctionnalitÃ©s et exigences  
3. ğŸ—ï¸ **Structure** â†’ Architecture de l'information et interactions  
4. ğŸ¦´ **Squelette** â†’ Wireframes et navigation  
5. ğŸ¨ **Surface** â†’ Design final (UI)  

ğŸ’¡ **Analogie** : Construire un bÃ¢timent :  
- ğŸ¯ StratÃ©gie = Pourquoi construire ?  
- ğŸ“‹ PortÃ©e = Quels besoins ?  
- ğŸ—ï¸ Structure = Plan du bÃ¢timent  
- ğŸ¦´ Squelette = Murs et espaces  
- ğŸ¨ Surface = Peinture et finitions  

---

## ğŸ§  **Psychologie de lâ€™utilisateur**  

**ğŸ“Œ Charge cognitive**  

La **charge cognitive** correspond Ã  lâ€™effort mental nÃ©cessaire pour utiliser une interface. On distingue trois types :

| Type | DÃ©finition | Exemple en UI |
|------|-----------|---------------|
| **IntrinsÃ¨que** | ComplexitÃ© inhÃ©rente Ã  la tÃ¢che | Remplir une dÃ©claration fiscale reste complexe quel que soit le design |
| **ExtrinsÃ¨que** | ComplexitÃ© ajoutÃ©e par un mauvais design | Un menu de navigation avec 20 liens non triÃ©s |
| **Germane** (pertinente) | Effort utile qui aide Ã  apprendre | Un tutoriel interactif qui guide pas Ã  pas |

âœ… **Lâ€™objectif en UX** : rÃ©duire la charge **extrinsÃ¨que** (parasites) et maximiser la charge **germane** (apprentissage utile).

ğŸ’¡ **Bonnes pratiques pour rÃ©duire la charge cognitive** :
- ğŸ§© **DÃ©couper les tÃ¢ches complexes** en Ã©tapes simples (ex. un formulaire en plusieurs Ã©tapes plutÃ´t quâ€™une seule page)
- ğŸ·ï¸ **Utiliser des labels clairs** plutÃ´t que des icÃ´nes ambiguÃ«s
- ğŸ“ **Limiter le nombre dâ€™informations visibles** Ã  un instant donnÃ© (la mÃ©moire de travail retient environ **7 Â± 2 Ã©lÃ©ments** â€” loi de Miller)
- ğŸ¯ **HiÃ©rarchiser visuellement** pour guider lâ€™Å“il vers lâ€™essentiel en premier

**ğŸ“Œ Affordances**  

Une **affordance** est la capacitÃ© dâ€™un Ã©lÃ©ment Ã  **suggÃ©rer visuellement son usage**, sans explication.

| Type dâ€™affordance | DÃ©finition | Exemple |
|---------------------|-----------|---------|
| **Explicite** | Lâ€™Ã©lÃ©ment montre clairement comment lâ€™utiliser | Un bouton en relief avec un texte Â« Cliquer ici Â» |
| **Implicite** (pattern) | Lâ€™utilisateur connaÃ®t le comportement par habitude | Un texte bleu soulignÃ© = lien cliquable |
| **MÃ©taphorique** | Lâ€™interface imite un objet du monde rÃ©el | Lâ€™icÃ´ne poubelle ğŸ—‘ï¸ = supprimer |
| **NÃ©gative** | Lâ€™Ã©lÃ©ment montre quâ€™il nâ€™est **pas** interactif | Un bouton grisÃ©/dÃ©sactivÃ© |

ğŸ’¡ **Exemples concrets en web** :
- Un champ de formulaire avec un **placeholder** (ex. Â« Entrez votre email Â») â†’ affordance explicite
- Un **bouton dÃ©sactivÃ©** (`disabled`) en grisÃ© â†’ affordance nÃ©gative : lâ€™utilisateur comprend quâ€™il ne peut pas cliquer
- Un **Ã©lÃ©ment avec `cursor: pointer`** au survol â†’ affordance implicite

> ğŸ“Œ Une bonne affordance rÃ©duit le besoin de documentation : lâ€™utilisateur comprend **intuitivement** ce quâ€™il peut faire.

**ğŸ“Œ Lois UX importantes**  

#### âš–ï¸ Loi de Fitts â€” Taille et distance des cibles

**Formule** : le temps pour atteindre une cible dÃ©pend de sa **taille** et de sa **distance**.  
Plus un Ã©lÃ©ment est **grand et proche**, plus il est **rapide et facile** Ã  atteindre.

ğŸ’¡ **Applications concrÃ¨tes** :
- ğŸ”˜ Les **boutons dâ€™action principaux** (CTA) doivent Ãªtre grands et positionnÃ©s dans des zones faciles Ã  atteindre
- ğŸ“± Sur mobile, les **zones tactiles** doivent faire au minimum **44Ã—44 px** (recommandation Apple/Google)
- ğŸ–¥ï¸ Les menus placÃ©s en **bord dâ€™Ã©cran** sont plus faciles Ã  atteindre (la cible devient Â« infinie Â» car le curseur sâ€™arrÃªte au bord)
- âš ï¸ Ã€ lâ€™inverse, un petit bouton Â« Supprimer Â» Ã©loignÃ© du contenu rÃ©duit le risque de clic accidentel (utilisation dÃ©fensive de la loi de Fitts)

#### â±ï¸ Loi de Hick â€” Nombre de choix et temps de dÃ©cision

**Formule** : le temps de dÃ©cision augmente de faÃ§on **logarithmique** avec le nombre dâ€™options.

ğŸ’¡ **Applications concrÃ¨tes** :
- ğŸ” Un menu de navigation avec **5-7 Ã©lÃ©ments max** est plus efficace quâ€™un menu avec 15 options
- ğŸ›’ Sur un site e-commerce, proposer **3 formules tarifaires** plutÃ´t que 8 rÃ©duit le temps de dÃ©cision
- ğŸ” Un moteur de recherche avec **autocomplÃ©tion** rÃ©duit les options en filtrant au fur et Ã  mesure
- ğŸ“‹ Regrouper les options en **catÃ©gories** (ex. un mega menu organisÃ©) aide lâ€™utilisateur Ã  scanner plus vite

> ğŸ“Œ **Attention** : la loi de Hick ne dit pas Â« moins de choix = mieux Â». Elle dit que les choix doivent Ãªtre **organisÃ©s et hiÃ©rarchisÃ©s** pour faciliter la prise de dÃ©cision.

#### ğŸ‘ï¸ Lois de la Gestalt â€” Comment le cerveau organise les informations visuelles

Les lois de la **Gestalt** (psychologie de la forme) dÃ©crivent comment notre cerveau **regroupe et interprÃ¨te** les Ã©lÃ©ments visuels :

| Loi | Principe | Exemple en UI |
|-----|----------|---------------|
| **ProximitÃ©** | Les Ã©lÃ©ments proches sont perÃ§us comme liÃ©s | Un label placÃ© juste au-dessus de son champ de formulaire |
| **SimilaritÃ©** | Les Ã©lÃ©ments similaires (couleur, forme) sont perÃ§us comme un groupe | Tous les liens dâ€™une mÃªme couleur dans une navigation |
| **ContinuitÃ©** | Lâ€™Å“il suit naturellement les lignes et les courbes | Un fil dâ€™Ariane (breadcrumb) horizontal guide le regard |
| **Fermeture** | Le cerveau Â« complÃ¨te Â» les formes incomplÃ¨tes | Un logo composÃ© de formes ouvertes mais perÃ§u comme un tout |
| **Figure/fond** | Le cerveau distingue un Ã©lÃ©ment principal dâ€™un arriÃ¨re-plan | Un modal (figure) qui assombrit le fond de la page |

---

## ğŸ¨ **AccessibilitÃ© et design inclusif**

ğŸ“Œ **Pourquoi câ€™est essentiel ?**  
- 15% de la population mondiale a un handicap.  
- Un bon design UX est accessible Ã  tous (personnes malvoyantes, daltoniennes, dyslexiquesâ€¦).  

âœ… **Bonnes pratiques UX pour lâ€™accessibilitÃ©**  
- **Contraste suffisant** entre texte et fond (ratio minimum **4.5:1** pour le texte normal et **3:1** pour le texte large selon les **WCAG 2.1**, niveau AA).  
- **Navigation clavier** et compatibilitÃ© avec les lecteurs dâ€™Ã©cran.  
- **Texte alternatif** pour les images.  
- **Ã‰viter le texte seul pour lâ€™information** (utiliser icÃ´nes et couleurs complÃ©mentaires).  

<Cards>
  <Cards.Card
    icon={<Figma />}
    title="Projet FIGMA"
    href="https://champollion-ux-ui.figma.site/"
  />
</Cards>

---