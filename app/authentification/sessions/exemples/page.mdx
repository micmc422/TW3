---
description: "Dans cette activitÃ©, nous allons implÃ©menter un systÃ¨me dâ€™authentification utilisant des JSON Web Tokens (JWT) avec Node.js et Express. Ce systÃ¨me permettra aux utilisateurs de s'inscrire, de se connecter et d'accÃ©der Ã  des routes protÃ©gÃ©es uniquement s'ils sont authentifiÃ©s via un JWT."
---
# ğŸ”’ **ActivitÃ© Pratique : Mise en Place dâ€™un SystÃ¨me dâ€™Authentification BasÃ© sur des JWT**

Dans cette activitÃ©, nous allons implÃ©menter un systÃ¨me dâ€™authentification utilisant des **<Term word="JSON">JSON</Term> Web Tokens (<Term word="JWT">JWT</Term>)** avec <Term word="Node.js">Node.js</Term> et <Term word="Express">Express</Term>. Ce systÃ¨me permettra aux utilisateurs de s'inscrire, de se connecter et d'accÃ©der Ã  des routes protÃ©gÃ©es uniquement s'ils sont authentifiÃ©s via un JWT.

---

## ğŸ” **Ã‰tapes Ã  Suivre**

### ğŸ” **1. Initialisation du Projet**

1. **CrÃ©er un nouveau projet Node.js :**  
   ```bash copy
   mkdir jwt-auth
   cd jwt-auth
   npm init -y
   npm install express bcrypt jsonwebtoken body-parser dotenv
   ```

2. **Configurer lâ€™environnement :**  
   CrÃ©ez un fichier `.env` Ã  la racine pour y stocker des variables sensibles :  
   ```plaintext copy
   JWT_SECRET=votre_secret_jwt
   PORT=3000
   ```

---

### ğŸ” **2. Structure des Fichiers**

Organisez les fichiers comme suit :  
```
jwt-auth/
â”œâ”€â”€ app.js
â”œâ”€â”€ .env
â””â”€â”€ package.json
```

---

### ğŸ” **3. Ã‰criture du Code**

**Fichier `app.js` :**
```javascript copy
const express = require('express');
const bodyParser = require('body-parser');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
app.use(bodyParser.json());

// Simuler une base de donnÃ©es
const users = [];

// Middleware pour vÃ©rifier les JWT
function authenticateToken(req, res, next) {
    const token = req.headers['authorization'] && req.headers['authorization'].split(' ')[1];
    if (!token) return res.status(401).send('AccÃ¨s non autorisÃ© : Aucun token fourni.');
    
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) return res.status(403).send('Token invalide.');
        req.user = user;
        next();
    });
}

// Route d'inscription
app.post('/register', async (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) return res.status(400).send('Nom dâ€™utilisateur et mot de passe requis.');

    // VÃ©rifier si l'utilisateur existe dÃ©jÃ 
    const existingUser = users.find(user => user.username === username);
    if (existingUser) return res.status(400).send('Utilisateur dÃ©jÃ  existant.');

    // Hacher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);
    users.push({ username, password: hashedPassword });
    res.status(201).send('Utilisateur enregistrÃ© avec succÃ¨s.');
});

// Route de connexion
app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    const user = users.find(user => user.username === username);
    if (!user) return res.status(400).send('Nom dâ€™utilisateur ou mot de passe incorrect.');

    // VÃ©rifier le mot de passe
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) return res.status(400).send('Nom dâ€™utilisateur ou mot de passe incorrect.');

    // GÃ©nÃ©rer un JWT
    const token = jwt.sign({ username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });
    res.json({ token });
});

// Route protÃ©gÃ©e
app.get('/protected', authenticateToken, (req, res) => {
    res.send(`Bienvenue ${req.user.username}, vous Ãªtes authentifiÃ©.`);
});

// DÃ©marrer le serveur
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Serveur en cours dâ€™exÃ©cution sur http://localhost:${PORT}`);
});
```

---

### ğŸ” **4. Tester lâ€™Application**

1. **DÃ©marrer le serveur :**  
   ```bash copy
   node app.js
   ```

2. **Inscription (POST /register) :**  
   Utilisez Postman ou curl pour envoyer une requÃªte :  
   ```json copy
   POST http://localhost:3000/register
   Content-Type: application/json

   {
       "username": "testuser",
       "password": "password123"
   }
   ```

   **RÃ©ponse attendue :**  
   ```
   Utilisateur enregistrÃ© avec succÃ¨s.
   ```

3. **Connexion (POST /login) :**  
   Envoyez une requÃªte pour obtenir un token JWT :  
   ```json copy
   POST http://localhost:3000/login
   Content-Type: application/json

   {
       "username": "testuser",
       "password": "password123"
   }
   ```

   **RÃ©ponse attendue :**  
   ```json copy
       "token": "<votre_jwt>"
   }
   ```

4. **AccÃ©der Ã  une route protÃ©gÃ©e (GET /protected) :**  
   Ajoutez le token dans les headers de la requÃªte :  
   ```
   Authorization: Bearer <votre_jwt>
   ```
   **RÃ©ponse attendue :**  
   ```
   Bienvenue testuser, vous Ãªtes authentifiÃ©.
   ```

5. **Tester un Token Invalide :**  
   Remplacez le token par un faux ou un expirÃ©, et observez la rÃ©ponse `401` ou `403`.

---

## ğŸ” **Explications Techniques**

1. **bcrypt :**  
   UtilisÃ© pour hacher et vÃ©rifier les mots de passe afin quâ€™ils ne soient jamais stockÃ©s en clair.  

2. **jsonwebtoken :**  
   - `jwt.sign` gÃ©nÃ¨re un token avec un payload (donnÃ©es utilisateur).  
   - `jwt.verify` vÃ©rifie si un token est valide et non expirÃ©.

3. **Middleware `authenticateToken` :**  
   ProtÃ¨ge les routes sensibles en exigeant un JWT valide dans les headers.

4. **Expiration du Token :**  
   Le token est configurÃ© pour expirer aprÃ¨s 1 heure (`expiresIn: '1h'`). Cela rÃ©duit le risque dâ€™abus en cas de vol du token.

---

## ğŸ” **AmÃ©liorations Futures**
- Ajouter une base de donnÃ©es rÃ©elle (<Term word="MongoDB">MongoDB</Term>, MySQL) pour stocker les utilisateurs.  
- GÃ©rer la rÃ©vocation de tokens via une liste noire.  
- Chiffrer les donnÃ©es sensibles dans les payloads JWT si nÃ©cessaire.  
- Utiliser `HttpOnly` et `Secure` pour transporter les JWT dans des cookies sÃ©curisÃ©s.

---

Ce systÃ¨me vous donne une base solide pour implÃ©menter un mÃ©canisme d'authentification moderne basÃ© sur des JWT, adaptable aux APIs <Term word="REST">REST</Term> ou aux <Term word="microservices">microservices</Term>.